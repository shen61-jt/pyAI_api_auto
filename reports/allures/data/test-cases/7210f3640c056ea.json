{"uid":"7210f3640c056ea","name":"test_register[case7]","fullName":"testcases.student.test_1_register#test_register","historyId":"376da41409ee43b55e0bf5ab2fa8bb25","time":{"start":1758533419293,"stop":1758533419302,"duration":9},"description":"描述：登录测试模块","descriptionHtml":"<p>描述：登录测试模块</p>\n","status":"broken","statusMessage":"requests.exceptions.ProxyError: HTTPSConnectionPool(host='minicourse.test.venhalo.com', port=443): Max retries exceeded with url: /api/v1/user/par (Caused by ProxyError('Unable to connect to proxy', SSLError(SSLEOFError(8, 'EOF occurred in violation of protocol (_ssl.c:1129)'))))","statusTrace":"urllib3.exceptions.SSLError: EOF occurred in violation of protocol (_ssl.c:1129)\n\nThe above exception was the direct cause of the following exception:\nurllib3.exceptions.SSLError: EOF occurred in violation of protocol (_ssl.c:1129)\n\nThe above exception was the direct cause of the following exception:\n\nurllib3.exceptions.ProxyError: ('Unable to connect to proxy', SSLError(SSLEOFError(8, 'EOF occurred in violation of protocol (_ssl.c:1129)')))\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E4E0D118B0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = Timeout(connect=None, read=None, total=None), verify = True\ncert = None\nproxies = OrderedDict([('http', 'http://127.0.0.1:7890'), ('https', 'https://127.0.0.1:7890'), ('ftp', 'ftp://127.0.0.1:7890')])\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection_with_tls_context(\n                request, verify, proxies=proxies, cert=cert\n            )\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\nvenv\\lib\\site-packages\\requests\\adapters.py:644: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nvenv\\lib\\site-packages\\urllib3\\connectionpool.py:841: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\nmethod = 'GET', url = '/api/v1/user/par', response = None\nerror = ProxyError('Unable to connect to proxy', SSLError(SSLEOFError(8, 'EOF occurred in violation of protocol (_ssl.c:1129)')))\n_pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E4E0D11730>\n_stacktrace = <traceback object at 0x000001E4DF8E5080>\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='minicourse.test.venhalo.com', port=443): Max retries exceeded with url: /api/v1/user/par (Caused by ProxyError('Unable to connect to proxy', SSLError(SSLEOFError(8, 'EOF occurred in violation of protocol (_ssl.c:1129)'))))\n\nvenv\\lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\ncase = {'提取响应字段': None, '数据库断言': None, '期望结果': '{\"$.data.children[0].name\":{\"$ne\":\"更新test学生\"}}', '用例标题': '获取当前用户信息（家长）', ...}\n\n    @allure.epic('AI学生端项目')\n    @allure.feature('登录模块')\n    @allure.description(\"描述：登录测试模块\")\n    @allure.link(url=\"https://minicourse.test.venhalo.com\", name=\"接口地址\")\n    @allure.severity(allure.severity_level.BLOCKER)\n    @pytest.mark.parametrize('case', case_datas)\n    def test_register(case):\n>       res = send_request(case)\n\ntestcases\\student\\test_1_register.py:29: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ncommon\\base_test.py:86: in send_request\n    res = request(method, url, headers=dic_headers)\nvenv\\lib\\site-packages\\requests\\api.py:59: in request\n    return session.request(method=method, url=url, **kwargs)\nvenv\\lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\nvenv\\lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E4E0D118B0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = Timeout(connect=None, read=None, total=None), verify = True\ncert = None\nproxies = OrderedDict([('http', 'http://127.0.0.1:7890'), ('https', 'https://127.0.0.1:7890'), ('ftp', 'ftp://127.0.0.1:7890')])\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection_with_tls_context(\n                request, verify, proxies=proxies, cert=cert\n            )\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n                raise RetryError(e, request=request)\n    \n            if isinstance(e.reason, _ProxyError):\n>               raise ProxyError(e, request=request)\nE               requests.exceptions.ProxyError: HTTPSConnectionPool(host='minicourse.test.venhalo.com', port=443): Max retries exceeded with url: /api/v1/user/par (Caused by ProxyError('Unable to connect to proxy', SSLError(SSLEOFError(8, 'EOF occurred in violation of protocol (_ssl.c:1129)'))))\n\nvenv\\lib\\site-packages\\requests\\adapters.py:671: ProxyError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"_session_faker","time":{"start":1758533416614,"stop":1758533416645,"duration":31},"status":"passed","steps":[],"attachments":[],"parameters":[],"hasContent":false,"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"stepsCount":0},{"name":"setup_class","time":{"start":1758533416645,"stop":1758533416646,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"hasContent":false,"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"stepsCount":0},{"name":"teardown_class","time":{"start":1758533416646,"stop":1758533416646,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"hasContent":false,"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"stepsCount":0}],"testStage":{"description":"描述：登录测试模块","status":"broken","statusMessage":"requests.exceptions.ProxyError: HTTPSConnectionPool(host='minicourse.test.venhalo.com', port=443): Max retries exceeded with url: /api/v1/user/par (Caused by ProxyError('Unable to connect to proxy', SSLError(SSLEOFError(8, 'EOF occurred in violation of protocol (_ssl.c:1129)'))))","statusTrace":"urllib3.exceptions.SSLError: EOF occurred in violation of protocol (_ssl.c:1129)\n\nThe above exception was the direct cause of the following exception:\nurllib3.exceptions.SSLError: EOF occurred in violation of protocol (_ssl.c:1129)\n\nThe above exception was the direct cause of the following exception:\n\nurllib3.exceptions.ProxyError: ('Unable to connect to proxy', SSLError(SSLEOFError(8, 'EOF occurred in violation of protocol (_ssl.c:1129)')))\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E4E0D118B0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = Timeout(connect=None, read=None, total=None), verify = True\ncert = None\nproxies = OrderedDict([('http', 'http://127.0.0.1:7890'), ('https', 'https://127.0.0.1:7890'), ('ftp', 'ftp://127.0.0.1:7890')])\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection_with_tls_context(\n                request, verify, proxies=proxies, cert=cert\n            )\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\nvenv\\lib\\site-packages\\requests\\adapters.py:644: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nvenv\\lib\\site-packages\\urllib3\\connectionpool.py:841: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\nmethod = 'GET', url = '/api/v1/user/par', response = None\nerror = ProxyError('Unable to connect to proxy', SSLError(SSLEOFError(8, 'EOF occurred in violation of protocol (_ssl.c:1129)')))\n_pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E4E0D11730>\n_stacktrace = <traceback object at 0x000001E4DF8E5080>\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='minicourse.test.venhalo.com', port=443): Max retries exceeded with url: /api/v1/user/par (Caused by ProxyError('Unable to connect to proxy', SSLError(SSLEOFError(8, 'EOF occurred in violation of protocol (_ssl.c:1129)'))))\n\nvenv\\lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\ncase = {'提取响应字段': None, '数据库断言': None, '期望结果': '{\"$.data.children[0].name\":{\"$ne\":\"更新test学生\"}}', '用例标题': '获取当前用户信息（家长）', ...}\n\n    @allure.epic('AI学生端项目')\n    @allure.feature('登录模块')\n    @allure.description(\"描述：登录测试模块\")\n    @allure.link(url=\"https://minicourse.test.venhalo.com\", name=\"接口地址\")\n    @allure.severity(allure.severity_level.BLOCKER)\n    @pytest.mark.parametrize('case', case_datas)\n    def test_register(case):\n>       res = send_request(case)\n\ntestcases\\student\\test_1_register.py:29: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ncommon\\base_test.py:86: in send_request\n    res = request(method, url, headers=dic_headers)\nvenv\\lib\\site-packages\\requests\\api.py:59: in request\n    return session.request(method=method, url=url, **kwargs)\nvenv\\lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\nvenv\\lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E4E0D118B0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = Timeout(connect=None, read=None, total=None), verify = True\ncert = None\nproxies = OrderedDict([('http', 'http://127.0.0.1:7890'), ('https', 'https://127.0.0.1:7890'), ('ftp', 'ftp://127.0.0.1:7890')])\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection_with_tls_context(\n                request, verify, proxies=proxies, cert=cert\n            )\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n                raise RetryError(e, request=request)\n    \n            if isinstance(e.reason, _ProxyError):\n>               raise ProxyError(e, request=request)\nE               requests.exceptions.ProxyError: HTTPSConnectionPool(host='minicourse.test.venhalo.com', port=443): Max retries exceeded with url: /api/v1/user/par (Caused by ProxyError('Unable to connect to proxy', SSLError(SSLEOFError(8, 'EOF occurred in violation of protocol (_ssl.c:1129)'))))\n\nvenv\\lib\\site-packages\\requests\\adapters.py:671: ProxyError","steps":[],"attachments":[{"uid":"f9c831f29bdf1e4b","name":"用例标题","source":"f9c831f29bdf1e4b.attach","type":"text/plain","size":36},{"uid":"12ae84e1c901c5ce","name":"请求方法","source":"12ae84e1c901c5ce.attach","type":"text/plain","size":3},{"uid":"17b5253f9a9db453","name":"请求地址","source":"17b5253f9a9db453.attach","type":"text/plain","size":51},{"uid":"f086cfe093d17dfa","name":"请求头","source":"f086cfe093d17dfa.txt","type":"text/plain","size":83}],"parameters":[],"hasContent":true,"shouldDisplayMessage":true,"attachmentsCount":4,"attachmentStep":false,"stepsCount":0},"afterStages":[{"name":"teardown_class::0","time":{"start":1758533453517,"stop":1758533453559,"duration":42},"status":"passed","steps":[],"attachments":[{"uid":"a29addc18b2579d0","name":"fixture后置处理","source":"a29addc18b2579d0.txt","type":"text/plain","size":18}],"parameters":[],"hasContent":true,"shouldDisplayMessage":false,"attachmentsCount":1,"attachmentStep":false,"stepsCount":0},{"name":"setup_class::0","time":{"start":1758533453560,"stop":1758533453560,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"hasContent":false,"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"stepsCount":0}],"labels":[{"name":"feature","value":"登录模块"},{"name":"severity","value":"blocker"},{"name":"epic","value":"AI学生端项目"},{"name":"parentSuite","value":"testcases.student"},{"name":"suite","value":"test_1_register"},{"name":"host","value":"DESKTOP-GLFP8VP"},{"name":"thread","value":"104384-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"testcases.student.test_1_register"},{"name":"resultFormat","value":"allure2"}],"parameters":[{"name":"case","value":"{'用例编号': 8, '用例标题': '获取当前用户信息（家长）', '请求地址': 'https://minicourse.test.venhalo.com/api/v1/user/par', '请求方法': 'GET', '请求头': '{\"Authorization\":\"Bearer ${token}\",\"Content-Type\":\"application/json;charset=utf-8\"}', '请求参数': None, '期望结果': '{\"$.data.children[0].name\":{\"$ne\":\"更新test学生\"}}', '数据库断言': None, '提取响应字段': None}"}],"links":[{"name":"接口地址","url":"https://minicourse.test.venhalo.com","type":"link"}],"hidden":false,"retry":false,"extra":{"severity":"blocker","retries":[],"categories":[{"name":"Test defects","matchedStatuses":[]}],"tags":[]},"source":"7210f3640c056ea.json","parameterValues":["{'用例编号': 8, '用例标题': '获取当前用户信息（家长）', '请求地址': 'https://minicourse.test.venhalo.com/api/v1/user/par', '请求方法': 'GET', '请求头': '{\"Authorization\":\"Bearer ${token}\",\"Content-Type\":\"application/json;charset=utf-8\"}', '请求参数': None, '期望结果': '{\"$.data.children[0].name\":{\"$ne\":\"更新test学生\"}}', '数据库断言': None, '提取响应字段': None}"]}